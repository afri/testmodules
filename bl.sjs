// blocklambda streaming demo functions

function help() {
  console.log("
This module contains some demo code for the 'block lambda' feature implemented in the
most recent trunk version of Oni Labs' StratifiedJS implementation 'Apollo'.

For more information, please see the Oni Apollo mailing list: https://groups.google.com/forum/#!forum/oni-apollo

*** FUNCTIONS EXPORTED BY THIS MODULE *** (for source code see https://github.com/afri/testmodules/blob/master/bl.sjs):

- CLIENT-SIDE AND SERVER-SIDE:

stream(arr)     : create a lazy stream from an array
head(s)         : get the first item from a stream
pick(count, s)  : create a stream containing the first 'count' elements of stream 's'
integers(start) : create a stream of integers beginning with 'start' (default: 0)
collect(s)      : collect stream into an array
filter(p, s)    : create a stream of elements in stream 's' that satisfy predicate 'p'
map(fn, s)      : create a stream fn(x_1), fn(x_2), ... where x_n are elements from stream 's'
cons(head, s)   : create a stream consisting of element 'head' and all elements from stream 's'
primes()        : create a stream of prime numbers generated by elegant but non-scalable recursive sieve of eratosthenes
primes2()       : create a stream of prime numbers generated iteratively (better, but still slow)
fib()           : create a stream of fibonacci numbers
split(sep, s)   : create a stream that chunks string-stream 's' into strings separated by 'sep'
lines(s)        : create a stream that chunks string-stream 's' into lines

- SERVER-SIDE ONLY:

readDir(path)   : create a stream of filenames in directory 'path':
openFile(path)  : open the file at 'path' and pass it into a block; close file at end of block

The file object injected into a block by openFile contains the members:
read()          : create a stream of the file contents
stat()          : return information about the file

*** EXAMPLES ***

>  stream([3,2,1]) { |x| console.log(x); hold(1000); }            // 3,2,1 printed at 1s intervals
>  pick(10, primes()) { |x| console.log(x) }                      // first 10 primes
>  pick(10, filter({ |x| x%2==0 }, fib())) { |x| console.log(x) } // first 10 even fibonacci numbers 
>  readDir('.') { |x| console.log(x) }                             // list files in '.' (server-side only)
>  openFile('foo') { |file| var i=0; lines(file.read()) { |line| console.log(i++ + '> ' + line); } }
");
}

if (require('sjs:apollo-sys').getGlobal()['console'])
  help();

//----------------------------------------------------------------------
// create a stream from an array:
function stream(arr) {
  var i=0; 
  return { |f| while (i<arr.length) f(arr[i++]); }
}
exports.stream = stream;

//----------------------------------------------------------------------
// get the first item of a stream:
function head(s) {
  s { |x| return x; }
}
exports.head = head;

//----------------------------------------------------------------------
// create a stream containing the first 'count' elements of stream 's':
function pick(count, s) {
  return { |f|
           while (count-->0)
             f(head(s));
         }
}
exports.pick = pick;

//----------------------------------------------------------------------
// create a stream of integers beginning with 'start' (default: 0):
function integers(start) {
  var i= start || 0;
  return { |f| while (1) f(i++) }
}
exports.integers = integers;

//----------------------------------------------------------------------
// collect stream into an array:
function collect(s) {
  var rv = [];
  s { |x| rv.push(x) }
  return rv;
}
exports.collect = collect;

//----------------------------------------------------------------------
// create a stream of elements in 's' that satisfy 'predicate':
function filter(predicate, s) {
  return { |f|
           while (1) {
             var x = head(s);
             if (predicate(x)) f(x);
           }
         }
}
exports.filter = filter;

//----------------------------------------------------------------------
// create a stream fn(x_1), fn(x_2), ... where x_n are elements from
// stream 's':
function map(fn, s) {
  return { |g| s { |x| g(fn(x)) } }
}
exports.map = map;

//----------------------------------------------------------------------
// create a stream consisting of element 'head' and all elements from
// stream 's':
function cons(head, s) {
  var first = true;
  return { |f| 
           if (first) {
             first = false;
             f(head);
           } 
           s(f);
         };
}
exports.cons = cons;

//----------------------------------------------------------------------
// create a stream of prime numbers generated by a naive, non-scalable,
// recursive sieve of eratosthenes:
function primes() {
  var s = arguments[0] || integers(2);
  var h = head(s);
  return cons(h, { |f| primes(filter({ |x| x%h }, s))(f) });
}
exports.primes = primes;

//----------------------------------------------------------------------
// create a stream of prime numbers generated iteratively (better than
// recursive implementation, but still slow)
function primes2() {
  var P = [];
  var I = integers(2);
  return { |f| 
           while (1) {
             var p = head(filter(function(x) { 
               var max = Math.sqrt(x), i=0, l=P.length, p;
               for (;i<l && (p=P[i])<=max;++i)
                 if (x%p==0) return false;
               return true;
             }, 
                                 I));
             P.push(p);
             f(p);
           }
         }
}
exports.primes2 = primes2;

//----------------------------------------------------------------------
// create a stream of fibonacci numbers
function fib() {
  var i1 = 1, i2 = 1;
  return { |f| 
           while (1) {
             var i = i1;
             [i1, i2] = [i2, i1+i2];
             f(i);
           }
         };
};
exports.fib = fib;

//----------------------------------------------------------------------
// create a stream that chunks string stream 's' into strings
// separated by 'separator':
exports.split = function split(separator, s) {
  var buf = "", pos, tmp;
  return { |f|
           while (1) {
             while ((pos = buf.indexOf(separator)) != -1) {
               tmp = buf.substr(0,pos);
               buf = buf.substr(pos+1);
               f(tmp);
             }
             s { |chunk| buf += chunk; continue; }
             break;
           }
           if (buf.length) {
             var tmp = buf;
             buf = "";
             f(tmp);
           }
         }
};

//----------------------------------------------------------------------
// create a stream that chunks string stream 's' into lines:
exports.lines = function(s) {
  return split("\n", s);
};


////////////////////////////////////////////////////////////////////////
// the following file-related functions are server-side only

if (require('sjs:apollo-sys').hostenv == "nodejs") {

  var fs = require('apollo:node-fs'); 

  //----------------------------------------------------------------------
  // create a stream of filenames in directory 'path':
  exports.readDir = function(path) {
    return stream(fs.readdir(path));
  };

  //----------------------------------------------------------------------
  // File object created in 'openFile' block
  var File = function (fd, encoding) {
    this.fd = fd;
    this.encoding = encoding || 'utf8';
  }
  File.prototype = {
    // create a stream of the file contents:
    read : function() {
      var pos = 0;
      var bufLen = 64*1024;
      var buffer = new Buffer(bufLen);
      var decoder = new (require('string_decoder').StringDecoder)(this.encoding);
      return { |f|
               while (1) {
                 var bytesRead = fs.read(this.fd, buffer, 0, bufLen, pos);
                 if (!bytesRead) break;
                 pos += bytesRead;
                 var string = decoder.write(buffer.slice(0,bytesRead));
                 if (string.length) 
                   f(string);
               }
             }
    },
    // stat the file:
    stat : function() {
      return fs.fstat(this.fd);
    }
  };

  // open the file at 'path' and pass it into a block; close file
  // at end of block
  exports.openFile = function(path, flags, mode) { 
    var fd = fs.open(path, flags || 'r', mode);
    var file = new File(fd);
    return { |f| try { f(file); } finally { fs.close(fd);} };
  };
}
