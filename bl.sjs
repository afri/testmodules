// blocklambda streaming demo functions

//----------------------------------------------------------------------
// create a stream from an array:
function stream(arr) {
  var i=0; 
  return { |f| while (i<arr.length) f(arr[i++]); }
}
exports.stream = stream;

//----------------------------------------------------------------------
// get the first item of a stream:
function head(s) {
  s { |x| return x; }
}
exports.head = head;

//----------------------------------------------------------------------
// create a stream containing the first 'count' elements of stream 's':
function pick(count, s) {
  return { |f|
           while (count-->0)
             f(head(s));
         }
}
exports.pick = pick;

//----------------------------------------------------------------------
// create a stream of integers beginning with 'start' (default: 0):
function integers(start) {
  var i= start || 0;
  return { |f| while (1) f(i++) }
}
exports.integers = integers;

//----------------------------------------------------------------------
// collect stream into an array:
function collect(s) {
  var rv = [];
  s { |x| rv.push(x) }
  return rv;
}
exports.collect = collect;

//----------------------------------------------------------------------
// create a stream of elements in 's' that satisfy 'predicate':
function filter(predicate, s) {
  return { |f|
           while (1) {
             var x = head(s);
             if (predicate(x)) f(x);
           }
         }
}
exports.filter = filter;

//----------------------------------------------------------------------
// create a stream fn(x_1), fn(x_2), ... where x_n are elements from
// stream 's':
function map(fn, s) {
  return { |g| s { |x| g(fn(x)) } }
}
exports.map = map;

//----------------------------------------------------------------------
// create a stream consisting of element 'head' and all elements from
// stream 's':
function cons(head, s) {
  var first = true;
  return { |f| 
           if (first) {
             first = false;
             f(head);
           } 
           s(f);
         };
}
exports.cons = cons;

//----------------------------------------------------------------------
// create a stream of prime numbers generated by naive, non-scalable,
// recursive sieve of eratosthenes:
function primes() {
  var s = arguments[0] || integers(2);
  var h = head(s);
  return cons(h, { |f| primes(filter({ |x| x%h }, s))(f) });
}
exports.primes = primes;

//----------------------------------------------------------------------
// create a stream of prime numbers generated iteratively (better than
// recursive implementation, but still slow)
function primes2() {
  var P = [];
  var I = integers(2);
  return { |f| 
           while (1) {
             var p = head(filter(function(x) { 
               var max = Math.sqrt(x), i=0, l=P.length, p;
               for (;i<l && (p=P[i])<=max;++i)
                 if (x%p==0) return false;
               return true;
             }, 
                                 I));
             P.push(p);
             f(p);
           }
         }
}
exports.primes2 = primes2;

//----------------------------------------------------------------------
// create a stream of fibonacci numbers
function fib() {
  var i1 = 1, i2 = 1;
  return { |f| 
           while (1) {
             var i = i1;
             [i1, i2] = [i2, i1+i2];
             f(i);
           }
         };
};
exports.fib = fib;

//----------------------------------------------------------------------
// create a stream that chunks string stream 's' into strings
// separated by 'separator':
exports.split = function split(separator, s) {
  var buf = "", pos, tmp;
  return { |f|
           while (1) {
             while ((pos = buf.indexOf(separator)) != -1) {
               tmp = buf.substr(0,pos);
               buf = buf.substr(pos+1);
               f(tmp);
             }
             s { |chunk| buf += chunk; continue; }
             break;
           }
           if (buf.length) {
             var tmp = buf;
             buf = "";
             f(tmp);
           }
         }
};

//----------------------------------------------------------------------
// create a stream that chunks string stream 's' into lines:
exports.lines = function(s) {
  return split("\n", s);
};


////////////////////////////////////////////////////////////////////////
// the following file-related functions are server-side only

if (require('sjs:apollo-sys').hostenv == "nodejs") {

  var fs = require('apollo:node-fs'); 

  //----------------------------------------------------------------------
  // create a stream of filenames in directory 'path':
  exports.readDir = function(path) {
    return stream(fs.readdir(path));
  };

  //----------------------------------------------------------------------
  // File object created in 'openFile' block
  var File = function (fd, encoding) {
    this.fd = fd;
    this.encoding = encoding || 'utf8';
  }
  File.prototype = {
    // create a stream of the file contents:
    read : function() {
      var pos = 0;
      var bufLen = 64*1024;
      var buffer = new Buffer(bufLen);
      var decoder = new (require('string_decoder').StringDecoder)(this.encoding);
      return { |f|
               while (1) {
                 var bytesRead = fs.read(this.fd, buffer, 0, bufLen, pos);
                 if (!bytesRead) break;
                 pos += bytesRead;
                 var string = decoder.write(buffer.slice(0,bytesRead));
                 if (string.length) 
                   f(string);
               }
             }
    },
    // stat the file:
    stat : function() {
      return fs.fstat(this.fd);
    }
  };

  // open the file at 'path' and pass it into a block; close file
  // at end of block
  exports.openFile = function(path, flags, mode) { 
    var fd = fs.open(path, flags || 'r', mode);
    var file = new File(fd);
    return { |f| try { f(file); } finally { fs.close(fd);} };
  };
}